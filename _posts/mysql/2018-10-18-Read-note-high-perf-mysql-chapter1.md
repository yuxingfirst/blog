---
title: 高性能Mysql - Chapter1
layout: post
categories: [Mysql]
tags: [mysql, 读书笔记]
---

![](https://raw.githubusercontent.com/yuxingfirst/blog/gh-pages/_images/mysql/highperformance-mysql-chapter1-p1.png)

如上是本书第一章的内容概要， 总体来说有如下几块重要的内容：

###一、逻辑架构
1. 每个客户端连接都会有一个线程，该连接的查询只会在这个单独的线程中执行；另外服务器会负责缓存线程，也就是说服务器会维护一个线程池，并不需要为每个新建的连接创建/销毁线程。
2. 每次查询之后，服务器会先检查查询缓存（Query Cache），如果能在其中找到对应的查询，就会直接返回结果。

####二、并发控制
通常如果所有的请求都是只读，是不需要做并发控制的。但是当同一时刻有多个请求修改同一份数据时；或者一个请求在读取数据，而另一个请求正在删除数据，都有可能导致出错。解决这类经典问题的方法就是要做并发控制。

#####读写锁
要做并发控制，一般可以在处理并发的读或写时，实现一个由两种类型的所组成的锁系统来解决。

1. 读锁（read lock，共享锁）
	读锁是共享的，相互不阻塞，也就是说多个客户端在同一时刻可以获取同一把读锁而不阻塞。
2. 写锁（write lock, 排他锁）
	写锁是排他的，一个写锁会阻塞其他的所有读锁和写锁。
	
######锁粒度
为了让系统的性能更好，在用锁处理并发问题时，我们还需要考虑锁的粒度问题，也就是让锁定的对象更有选择性来提供共享资源的并发性。一种理想的方式是只对需要修改的数据片进行锁定，通常在给定资源下，锁的数据量越少，则系统的并发程度越高。
但是，加锁也是需要消耗资源的，并且锁越多管理成本也越高，随之而来的系统开销也越大，反而也会对系统性能带来影响。所以我们在设计锁的策略时，需要在锁的开销和数据安全性之间寻求平衡。

在MySQL中，有两种常用的锁类型， 表锁（MyISAM）和行锁（InnoDB），两者各有优缺点。比如表锁，其锁的开销小，但是并发度可能不大；而行锁开销大但是并发度高。在某些读量远大于写量的系统中，可以考虑用表锁；而在读写量差距不大或者读少写多的场景中，则应该优先选用行锁。

####三、事务

首先我们先看下事务的四个基本特性（ACID）：

1. 原子性（Atomicity）
	一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

2. 一致性（Consistency）
	数据库总是从一个一致性的状态转换到另一个一致性的状态。当事务没有提交之前如果遇到系统崩溃，崩溃之前事务中的所做的修改也不会保存到数据库中。
	
3. 隔离性（Isolation）
	通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。不过当后续讲到事务的隔离级别时就会知道这里说的“通常不可见”只是其中一种情况。
	
4. 持久性（Durability）
	一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃， 修改的数据也不会丢失。
	
	*PS：持久性我理解就是修改并提交了的数据能在数据库中持久保存（数据不丢），但是书中也提到说持久性是一个相对模糊的概念，理论上数据库本身也没法保证单机100%持久（单机硬盘故障、机房故障等等都有可能造成数据丢失），所以要保证数据的持久性，需要我们根据数据的重要程度做不同等级容灾保护。*

在MySQL常用的两种存储引擎中， MyISAM不支持事务、InnoDB支持事务。

####四、隔离级别
SQL标准中定义了四种隔离级别， 每一种都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的，较低级别的隔离级别可以执行更高的并发，系统的开销也更低。

1. READ UNCOMMITTED（未提交读）
	在事务中可以看到其他事务未提交的数据，称为脏读（dirty read）；此隔离级别一般很少使用。
2. READ COMMITTED （提交读）
	一个事务只能看到已经提交的事务所做的修改。 也叫不可重复读，是因为有可能在事务中前后两次读取同样的记录可能读取到不同的数据。（除MySQL之外，大多数数据库系统的默认隔离级别都为READ COMMITTED）。
3. REPETABLE READ（可重复读）
	保证在事务中多次读取同样记录的结果是一致的。但会存在“幻读”问题（当某个事务读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生“幻行”），InnoDB通过MVCC解决幻读问题。
	InnoDB的默认隔离级别是 REPETABLE READ。
4. SERIALIZABLE
	强制事务串行执行，避免了幻读问题；由于在读取每一行数据时都加锁可能会导致大量的超时的锁争用，性能太差，一般也很少使用。
	
下表是SQL规范中不同隔离级别的对比：

	隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读
	------- | ------- | ------- | ----- | -----
	READ UNCOMMITTED | yes | yes | yes | no
	READ COMMITTED | no | yes | yes | no
	REPETABLE READ | no | no | yes | no
	SERIALIZABLE | no | no | no | yes
	
####五、死锁
如下两个事务所示的死锁例子：

```
Transaction 1

	start transaction;
	update stockprice set close = 50.0 where stock_id=4;
	update stockprice set close = 51.0 where stock_id=5;
	commit;
	
Transaction 2

	start transaction;
	update stockprice set close = 30.0 where stock_id=5;
	update stockprice set close = 31.0 where stock_id=4;
	commit;

```
如果这俩个事务同时执行了第一条语句，当执行第二条语句时就会发生死锁。  
死锁会导致很慢的查询，为了避免死锁的问题，数据库系统实现了各种死锁检测和死锁超时机制。 死锁超时机制一般是查询的时间达到锁等待的超时的设定后放弃锁请求，不过这种方式不太好，因为当发生死锁是查询等待必然会超过超时时间，是没必要的。  
InnoDB目前通过将持有最少行级排他锁的事务进行回滚。

####六、事务日志
使用事务日志的好处， 一是可以提高事务的效率，即当存储引擎在修改表的数据时，只需要先修改其内存拷贝，然后把该修改行为记录到磁盘上的事务日志中，并不用每次都讲数据本身持久化到磁盘。 后台可以根据事务日志上的修改行为异步的修改磁盘中的数据。  

*PS：这里能提高效率，主要是存储引擎在写事务日志时是采用的追加写（也就是顺序写）； 而如果直接写数据本身的话，可能是随机写。 因为在磁盘读写时，寻道和磁头移动是机械运动，效率很低，所以磁盘的顺序读写性能很高，而随机读写性能很差。*  

事务日志另一个好处就是可以进行数据恢复。在事务提交时，一般会确保事务日志记录到了磁盘，如果当数据还没有写回到磁盘时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。  

####七、MySQL中的事务  
1. 自动提交（autocommit）
	MySQL默认采用自动提交，如果不是显示的开启一个事务，则每个查询都被当做一个事务执行提交操作。可以通过AUTOCOMMIT变量来启用或者禁止***当前连接***的自动提交模式。  
	
	```
	show variables like 'autocommit'
	```
2. MySQL可以通过执行`set transaction isolation level`来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。 可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别。  
3. 不要在事务中混合使用事务型表和非事务型表。
4. 隐式和显示锁定
	InnoDB采用两阶段锁定协议，在事务执行过程中引擎会根据需要随时执行锁定，锁只有在commit或rollback时才会释放，并且所有的锁是在同一时刻释放。这种是隐式锁定，还有显示锁定，例如：  
	
	```
	select ... lock in share mode  
	select ... for update
	```

####八、多版本并发控制（MVCC）
基于提升性能的考虑，MySQL大多数事务型存储引擎都实现了MVCC，MVCC是行级锁的一个变种，它在很多情况下避免了加锁操作，开销更低。核心是非阻塞读，写操作也只锁定必要的行。不同的存储引擎其MVCC的实现方式不同，典型的有乐观并发控制和悲观并发控制。

####九、InnoDB和MyISAM存储引擎

######InnoDB

InnoDB采用MVCC来支持高并发，并且实现了4个标准的隔离级别。另外通过间隙锁（next-key locking）策略来防止幻读；间隙锁是的InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防幻影行的插入。
InnoDB的表示基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引中必须包含主键列。 所以如果主键列很大的话，其他所有的索引都会很大。因此如果表上的索引较多，主键应当尽可能小。

######MyISAM  

1. 表锁， 不支持事务和行级锁，崩溃后无法自动修复数据，有可能造成数据丢失。
2. 表存储分为两个文件： 数据文件（.MYD）和索引文件（.MYI），所以MyISAM单表可以存储的记录行数，受限于操作系统中单个文件的最大尺寸或者可用的磁盘空间。
3. 会保存整个表的总行数，所以`select count(*)`很快。

关于表存储引擎的选择，大多数情况选择MySQL默认的InnoDB都是没错的，不过如果自己的业务数据并不需要事务、崩溃恢复、数据只读等，也可以酌情选择其他引擎。  
另外就是采用DB存储时也需要考虑数据量的大小，采用InnoDB管理3 ~ 5TB或者更大的数据量时，一般不会有什么问题。 但是如果数据量达到10TB级别，就需要好好考虑是否需要建立数据仓库了。










