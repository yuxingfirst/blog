---
title: APUE读书笔记-Chapter3-文件I/O
layout: post
categories: [读书笔记]
tags: [读书笔记]
description: I/O函数介绍. 
---

一般,unix系统中的大多数文件I/O会需要用到常用的5个函数:  

    open
    read
    write
    lseek
    close

本章所介绍的文件io函数与c库提供的标准I/O函数不同,这些io函数通常是不带缓冲区的(unbuffered I/O), **不带缓冲区**指的是read和write调用用内核中的一个系统调用。这些不带缓冲区的I/O函数不是IOS C的组成部分。  

###文件描述符  
对于内核而言,所有打开的文件通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时, 内核向进程返回一个文件描述符。  

对于符合POSIX的应用程序中,0、1、2当替换成符号常量:  
    
    0 -> STDIN_FILENO
    1 -> STDOUT_FILENO
    2 -> STDERR_FILENO  

文件描述符的变化范围是0 ~ OPEN_MAX, 早期的UNIX系统实现采用的上限值是19(允许每个进程最多打开20个文件)，但现在很多系统则将其增至63。  

> 一般，在linux下我们是可以修改进程可以打开的最大文件描述符的数目的。  

###open函数

    #include <fcntl.h>
    int open(const char *pathname, int oflag, ... /* mode_t mode */);
                                                return: 成功则返回文件描述符否则返回-1 

pathname 为要打开/创建的文件的名字  
oflag 为打开/创建文件要进行的操作，除了常规的几个： 

1. O_RDONLY 只读  
2. O_WRONLY 只写  
3. RDWR     读写  
4. O_APPEND 追加
5. O_CREATE 若文件不存在则创建  

需要特别指出的是:  
1. O_DSYNC  使每次write等待物理I/O操作完成,但是如果写操作并不影响读取刚写入的数据,则不等待文件属性更新  
2. O_RSYNC  使每一个以文件描述符作为参数的read操作等待，直至任何对文件同一部分进行的未决写操作都完成  
3. O_SYNC   使每次write都等待物理I/O操作完成，包括由write操作引起的文件属性更新需要的I/O。   

> O_DSYNC和D_SYNC标志有微妙的区别。仅当文件属性需要更新以反映文件数据变化(例如,更新文件大小以返回文件中包含了更多的数据)时,
O_DSYNC标志才影响文件属性。而设置O_SYNC标志后,数据和属性总是同步更新。当文件用O_DSYNC标志打开，在重写其现有的部分内容时，
文件时间属性不会同步更新。与此相反, 如果文件是用O_SYNC标志打开，那么对该文件的每一次write操作都将在write返回前更新文件时间，
这与是否改写现有字节或增写文件无关。  

> linux 2.4.22将O_DSYNC O_RSYNC处理成与O_SYNC相同。  

由open返回的文件描述符一定是**最小的未用描述符值**。这一点被某些应用程序用来在标准输入、标准输出或标准错误输出上打开新的文件。  

例如，一个应用程序可以先关闭标准输出(STDOUT_FILENO), 然后打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符1上打开。

> 其实,我们能还可以使用dup2来在一个给定的描述符上打开一个文件.

###read函数

	#include <unistd.h>
	ssize_t read(int filedes, void *buf, size_t nbytes);  

如read成功, 则返回读到的字节数，如已到达文件结尾，则返回0。  
有多种情况可使实际读到的字节数少于要求读的字节数:   

1. 读普通文件时，在读到要求字节数之前已到达了文件尾端。例如，若在到达文件尾端之前还有30个字节，而要求读100字节，则read返回30，
下一次在调用read时，它将返回0(文件尾端)。  
2. 当从终端设备读时，通常一次最多读一行。  
3. 当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。  
4. 当从管道或FIFO读时，如若管道包含的字节数少于所需的数量，那么read将只返回实际可用的字节数。  
5. 当从某些面向记录的设备(如磁带)读时，一次最多返回一个记录。  
6. 当某一信号造成中断，而已经读了部分数据量时。  

> 读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数。  

###write函数

	#include <unistd.h>
	ssize_t write(int filedes, const void *buf, size_t nbytes);
								//成功返回已写的字节数，出错返回-1  

对于普通文件，写操作从文件的当前偏移量处开始。如果在打开该文件时指定了O_APPEND选项，则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。  

-EOF-


