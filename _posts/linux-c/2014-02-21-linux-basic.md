---
title: Linux编程基础
layout: post
categories: [linux-c]
tags: [linux-c]
description:  .
---  

###一、Linux进程内存布局  
![img1][linux-process-memory-layout]  

如上所示，是32位模式下linux内存布局。32位的程序寻址空间是 4G，即 0x00000000 ~ 0xffffffff， 从上往下以此为:  

1. 内核空间(Kernel)
2. 栈空间(Stack)
3. mmap(Memory Mapping Segment)
4. 堆空间(Heap)
5. 静态存储区(BSS segment)
6. 数据区(Data segment)
7. 文本段(Text segment)


栈空间：  
一般程序内的局部变量分配在栈空间，栈空间的地址是往下增长的。

堆空间：  
用malloc、new动态申请的内存分配在堆空间，堆空间的地址是往上增长的。

静态存储区：  
程序中未初始化的静态变量，会分配在这个区间，用0填充

数据区：  
如字符串常量，已初始化的静态变量，一般分配在这个区间

文本段：  
存储进程的二进制映像

	//
	int main(int argv, char *arg[])
	{
		static　int　ａ；	//静态存储区
		char *p = "msg";	//p 分配在栈区，字符串常量msg分配在
		int *pi = malloc(sizeof(int));	//malloc动态申请的内存分配在堆区
	}

###二、进程间通讯的方式
1. socket套接字，点对点，全双工通信。
2. pipe管道。参考：[linux进程通信之管道](http://coderworm.com//unix/2013/12/16/unix-process-communicate-a.html)  

###三、如何定位内存泄漏  
1. 检测工具： valgrind。
2. 打日志，记录一段内存的分配和释放记录。
3. gdb调试。  

###四、linux下动态链接(.so)和静态链接(.a)的区别
通常情况下，对函数库的链接是放在编译时完成的，所有相关的对象文件(.o)与程序中用到的函数库被链接合成一个可执行文件。这样，程序在运行时与函数库再也没有关联，因为所有需要用到的函数都已经拷贝到自己的区间了，类似这样在编译时链接的函数库称为静态链接(.a)。  

那么动态链接是什么呢？ 就是程序库在程序运行时才载入，也就是说，程序在运行中如果需要某个动态库时，操作系统会首先查看所有运行之中的程序是否已经加载过这个动态链接库了，如果已经加载过了，则这个程序直接共享这个已经加载到内存中的动态链接库。  
比如,有A、B、C三个程序，都需要用到libx.a, liby.so， 那么当A B C三个程序都运行时，对于libx.a，内存中会有三分拷贝；而对于liby.so，则只会存在一份拷贝。可见，动态链接库能够大大的节省系统资源。  

对于使用动态链接库，在程序升级时，也会相当方便，只需要升级动态库即可，自己的程序不需要重新编译；而如果使用的是静态库，则必须要重新编译程序了。  

类似于，标准c库 libc.so, libc++.so等这些，都是动态库。

所以，动态链接库的好处有：  

1. 可以实现进程之间的资源共享
2. 将一些程序升级变得简单。用户只需要升级动态链接库，而无需重新编译链接其他原有的代码就可以完成整个程序的升级
3. 甚至可以真正坐到链接载入完全由程序员在程序代码中控制  

###五、多线程和多进程的区别  

1： cpu调度

2： 上下文切换

3： 数据共享

4： 多核cpu利用率

5： 资源占用

6：一个线程私有的东西有哪些?


###六、常见的信号
	
	SIGHUP     	终止进程     		终端线路挂断
	SIGINT      终止进程     		中断进程
	SIGQUIT   	建立CORE文件终止进程，并且生成core文件
	SIGSEGV   	建立CORE文件       	段非法错误
	SIGBUS     	建立CORE文件       	总线错误
	SIGKILL   	终止进程     		杀死进程
	SIGALARM   	终止进程     		计时器到时
	SIGCHLD   	忽略信号     		当子进程停止或退出时通知父进程

###七、i++是否原子操作
原子操作，如果编译成一条指令，那么必定是原子操作；如果编译为多条指令，如果加了锁，则是原子操作，没加锁的话，就不一定是原子操作了。  

###八、各类linux系统同步机制
1： 互斥锁 mutex
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER


2： 信号量


###九、什么是死锁，如何避免死锁  

死锁发生的条件:   

1 互斥条件 
		
	即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。
	这种独占资源如CD-ROM，打印机等等，必须在占有该资源的进程主动释放后，其他的进程才可能
	占有该资源。

2 占有且等待  
	
	进程至少已经拥有了一个资源，但又申请新的资源；由于该新资源已被另外进程占有，此时该进程阻塞；
	但是在它等待其他资源的时候继续占有不释放已有的资源。

3 不可抢占  

	进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资
	源的占有者进程自行释放

4 环路等待  
	
	存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一
	源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环

如何避免:

1. 银行家算法(没研究过)
2. 按找同一种序列申请资源，释放资源(安全序列)

###十、举例说明各类linux系统的异步机制
socket套接字，异步非阻塞，IO多路复用，select, epoll

###十一、exit和_exit()的区别
exit是标准库函数，位于stdlib.h中，而 \_exit是unix系统函数，位于unistd.h。  
调用exit函数时，exit会执行一些额外的操作，而后再调用到内核级别的exit函数。如：为所有打开流调用fclose函数( 会造成所有缓冲的输出数据都被冲洗)，释放进程占用的内存。  
调用\_exit则直接退出。

###十二、如何实现守护进程
fork两次。  

	//
	pid_t pid = fork();
	switch(pid) {
		case -1:
			return;
		case 0:
			break;
		default:
			_exit();
	}

	pid = fork();
	switch(pid) {
		case -1:
			return;
		case 0:
			break;
		default:
			_exit();
	}
	//父进程变为了init

###十三、系统如何将一个信号通知到进程

###十四、c语言
1. 哪些库函数是高危函数(strcpy, strncpy)
2. 宏定义和展开
3. 位操作
4. 指针操作和计算
5. 内存分配


###十五、c++ string的实现(复制构造函数， 赋值操作符operator=)

###十六、虚函数的作用和实现原理


###十七、sizeof求一个类的大小(注意注意成员变量，函数，虚函数，继承等等对类大小的影响)

	class A
	{
	}

	sizeof(A) = 1

含有虚函数的类需要考虑虚函数表指针。

###十八、指针和引用的区别

###十九、extern c是干什么的(理清编译器的函数名修饰的机制)?

###二十、volatile的作用(cpu的寄存器缓存机制)

###二十一、hash, 为什么hashtable的桶数会去一个素数? 如何有效避免碰撞?  

###二十二、各类排序、快排(如何避免最糟糕的状态)

###二十三、tcp/udp的区别，udp调用connect的作用，tcp连接时序图，状态图

###二十四、select和epoll的区别，epoll有哪些触发模式(水平触发和边缘触发的区别以及边缘触发在编程中要做哪些更多的确认)

###二十五、 tcp结束链接怎么握手，time_wait状态是什么? 为什么会有time_wait? 哪一方会有time_wait状态? 如何避免time_wait状态占用资源?

###二十六、 对socket套接字设置非阻塞，如果select返回套接字可读，但返回0，什么情况?
对端关闭了链接(调用了close或者shutdown),tcp协议栈发送FIN分节。

###二十七、 常用tcp选项


[linux-process-memory-layout]: https://raw.github.com/yuxingfirst/blog/gh-pages/_images/linux-c/linux-process-memory-layout.png  

-EOF-
