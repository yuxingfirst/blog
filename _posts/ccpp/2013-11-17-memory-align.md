---
title: 内存对齐
layout: post
categories: [c]
tags: [c]
description: 内存对齐介绍.
---

###什么是内存对齐

对齐是跟数据在内存中位置相关的话题。如果一个变量的内存地址正好是它长度的整数倍，它就称作
是自然对齐的。举例来说，对于一个32为的类型的数据（通常会是4个字节），如果它在内存中的地
址刚好可以被4整除，那它就是自然对齐的。  

一些体系结构对对齐的要求非常严格。通常像RISC的系统，载入未对齐的数据会导致处理器陷入(一
种可处理的错误)；还有一些系统可以访问没有对齐的数据，只不过性能会下降。编写可移植的代码
要避免对齐问题，保证所有的类型都能够自然对齐。  

###标准及非标准类型对齐规则

对于标准数据类型来说，它的地址只要是其长度的整数倍就对齐了。而非标准的(复合的)C数据类型
按照下列原则对齐：  
1. 对于数组，只要按照基本数据类型进行对齐就可以了，随后的所有元素自然能够对齐。  
2. 对于联合体(union)，只要它包含的长度最大的数据类型能够对齐就可以了。  
3. 对于结构体，只要结构体中每个元素能够正确的对齐就可以了； 另外，对于结构体还要引入填
补机制  

> 对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的偏移量必须是min(#p
ragma pack()指定的数，这个数据成员的自身长度) 的倍数。  
> 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定
的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。  
> #pragma pack(n) 表示设置为n字节对齐。 VC6默认8字节对齐  

###示例

	#include <stdio.h>

    typedef struct Atag {
        char c;
        short s;
        int i;
    }A;

	int main(void) {
		printf("sizeof(A) = %d\n", sizeof(A));
		return 0;
	}  

上边的代码会输出什么?有人可能会说sizeof(A) = 7，的确，  
	
	sizeof(char) + sizeof(short) + sizeof(int) = 1 + 2 + 4 = 7  

但事情真的是这样吗?我们编译运行代码  

	$ gcc -o talign align_test.c -fpack-struct=4
	$ ./talign
	sizeof(A) = 8  

我们指定gcc按4字节对齐，输出为8。下边请看分析：  

char占一个字节，起始偏移为0， short占两个字节，如果编译器什么都不做，那么它的偏移地址就
是1，但这里就不满足内存对齐了，所以编译器会在char后添加一个额外字节，此时看起来应该是这
样: 
  
	x0|xx  

short的偏移变为2；接下来是int，有了前边的字节填充后，其偏移量为4，所以此时的内存结构看起
来应该是这样:  

	x0|xx|xxxx  

此时整个struct为8个字节，整体也满足了内存对齐，不需要再额外填充。所以sizeof输出为8。  

我们在来看另外一种情形:  

	typedef struct Btag {
		char c;
		int i;
		short s;
	}B;  

	$ gcc -o talign align_test.c -fpack-struct=2
	sizeof(B) = 8
	
	$ gcc -o talign align_test.c -fpack-struct=4
	sizeof(B) = 12  

大家可以想想为什么上边两种编译方式会有不同的输出。我就不另做解释了。  

###内存对齐的作用

1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能
在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2. 性能原因：经过内存对齐后，CPU的内存访问速度大大提升。  

在程序员看来，内存是一个字节一个字节组成的；不过从CPU的角度看来，内存是一块一块的，块的
大小可以有2，4，6，8，16字节大小，因此cpu读取内存时是一块一块进行读取的。  

假设CPU要读取一个int型4字节大小的数据到寄存器中，分两种情况讨论：  

1. 数据从0字节开始
2. 数据从1字节开始

我们假设内存的读取粒度(memory access granularity)是4  

![img1]({{ site.BASE_PATH }}/_images/linux-kernel/align-1.jpg)

当该数据是从0字节开始时，很CPU只需读取内存一次即可把这4字节的数据完全读取到寄存器中。  

当该数据是从1字节开始时，问题变的有些复杂，此时该int型数据不是位于内存读取边界上，这就
是一类内存未对齐的数据。  

![img2]({{ site.BASE_PATH }}/_images/linux-kernel/align-2.jpg)

此时CPU先访问一次内存，读取0—3字节的数据进寄存器，并再次读取4—5字节的数据进寄存器，接着
把0字节和6，7，8字节的数据剔除，最后合并1，2，3，4字节的数据进寄存器。对一个内存未对齐
的数据进行了这么多额外的操作，大大降低了CPU性能。  

-EOF-























