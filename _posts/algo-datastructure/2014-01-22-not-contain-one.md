---
title: 编程珠玑算法整理
layout: post
categories: [Algorithm]
tags: [Algorithm, 编程珠玑]
description: 编程珠玑算法整理. 
---

##### 2.1 给定包含40亿个随机排列的32位的整数文件，至少找出一个不在其中的整数。（分为内存足够和只有几百字节的内存但有几个外部的文件可以使用）。

首先来分析下为什么存在一个数不在其中，由于是32位整数的文件，而32位整数(无符号)表示的范围是：0 ~ 2^32-1 == 0 ~ 4,294,967,295， 42亿多，所以包含40亿个32位整数的文件必定会存在一个整数不在文件中。  

当内存足够的情况下，我们可以采用位图技术来解决，需要的内存为： 40 * 10^8 / 8 * 1024 * 1024，大概需要500M内存，然后将所有的位设置为0；然后顺序读取文件中的整数，将其对应的位置为1。处理完成后，遍历一遍位数组，就跟对应的位是否为0，就可以找到一个不在文件中的数了。  

	todo: c++ bitset实现

第二种情况，只有几百字节和几个外部文件，我们可以考虑二分的思想。首先需要确定的就是划分的依据，这里，我们以二进制位来考虑这40亿个整数。顺序读取文件，第31位为0的整数放入一个文件，第31位为1的整数放入一个文件，划分完成后，每个文件最多含有n/2个数，我们选取较少的那个文件，则必有一个数没在它里边；接着探测第30个位，按照同样的划分规则，也会得到两个文件。我们又选取整数少的那个文件，依次类推，探测第29个位......, 最后当探测到第0个位时，如果文件中对应的数不存在，那么就说明找到了一个不在文件中的整数。这里的时间复杂度为O(n)。

	todo:unsigned short 范围内的实现。

第三种方法，也可以排序文件后，执行查询操作，时间复杂度O(nlogn)。

##### 2.2 给定包含43亿个32位整数的文件，找出一个至少出现两次的整数。

(方法同上边的分析是一样的)

##### 2.3 n元数组x，给定数值t，找出t第一次出现的位置。

##### 2.4 字符串旋转(gcd移位，求逆，块交换)。
第一种方法，我们可以采用移位操作，这种方法中，关键一点是确认移位的次数以及合适终止一趟移位操作。首先，移位的次数是字符串的长度n和移动位数m的最大公约数，从i=0开始，每次将m, 2m,...,位置的约束移到0，m,..., 当i再次回到0时，一趟移位停止，开始第二趟移位。以此类推，直至移动完i=m为止，即可完成字符串的移位操作。  

第二种方法，求逆运算。例如，abcdefg，假设要左移3位，


##### 2.5 给定一本英文字典，查找所有的变位词集合。  

##### 2.6 二分法搜索，快速排序。  


##### 3.1 "咖啡豆问题"，起初给你提供了一个盛装了一些黑豆和白豆的咖啡罐以及一大堆额外的黑豆。然后你重复以下过程，知道罐中只剩一粒豆子为止：

1. 随机从罐中选择两粒豆子，如果他们的颜色一样，就将他们都扔掉，并且在罐中放入一颗额外的黑豆。如果他们的颜色不同，则将白豆放回罐中，并扔掉黑豆。  
2. 请证明该过程一定会终止。当一开始罐子里既有黑豆又有白豆时，你能说出罐子里最后剩下的豆子是什么颜色吗？   

##### 6.1 第六章开篇一个性能优化的例子，不同层面的性能优化可以获取叠加的加速系数。  

##### 7.1 估算，密西西比河一天流出多少水。

##### 7.2 
	
	struct node
	{
		int i;
		struct node *p;
	}

估算，128M主存的计算机能满足200w个这样的节点吗？  

##### 8.1 n维向量x，找出相邻子向量中和最大的那一个。
	
	31 | -41 | 59 | 64 | -1 | 0 | 99 | 9

##### 8.2 8.7习题5 9 10 11 14


-EOF-