---
title: The-C-Program-Language-读书笔记
layout: post
categories: [linux-c-cpp]
tags: [linux-c]
description: c语言编程读书笔记.
---


##Chapter1.导言


###1.8 参数-传值调用

1: 当把数组名用作函数参数时，传递给函数的值是数组起始元素的位置或地址---它并不复制数组元素本身。在被调用函数中可以通过数组的下标访问或修改数组元素的值。  
	
	void func(char buf[]) {	//仅演示目的  
		buf[0] = 1;  
		printf("%d\n", buf[1]);
	} 

2: c语言中，字符串常量以字符数组的形式存储，数组的各元素分别存储字符串的各个字符，并以'\0'标志字符串的结束。  
	
	即字符串常量会自动追加'\0'  

3: printf中的格式规范%s规定，对应的参数必须是以'\0'结束的字符串。  

4: 函数中的每个局部变量只在函数调用时存在，在函数执行完毕退出时消失。所以一般将局部变量成为自动变量(auto-variable)。  
	
	如果自动变量没有被复制，则其中存放的时无效值

5a: 除自动变量外，还可以定义位于**所有函数外部**的变量，即在所有函数中都可以通过变量名访问这种类型的变量。    
5b: 外部变量必须定义为所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。  
5c: 在每个需要访问外部变量的函数中，必须声明相应的外部变量。

	int max;

	void func(void) {
		extern int max;
		max = 1;
		//...
	}

5d: 某些情况下可以省略extern声明。在源文件中，如果外部变量的定义出现在使用它的函数之前，那么在那个函数中就没有必要使用extern。(在上边的例子中，func中的extern不是必须的)  

5e: 通常的做法是，所有外部变量的定义都放在元问及爱你的开始处，这样就可以省略extern声明。  

6: 在ANSI C中，如果要声明空参数表，则必须使用关键字void进行显示声明。 

	void func(void) {}  

7: 需要注意区分"定义(define)"和"声明(declaration)"的差别，"定义"标识创建变量或分配存储单元，而"声明"指的是说明变量的性质，但并不分配存储单元。  

--------------------------------------------------

##Chapter2.类型、运算符与表达式  

1: 字符串常量可以在编译时连接。例如:  

	#include <stdio.h>
	int main(void) {
		printf("test1" "test2\n");
		printf("test1"
				"test2\n");
		return 0;
	}  

2: c语言只提供了下列几种基本数据类型:

	char 字符型，占用一个字节，可以存放本地字符集中的一个字符
	int  整型，通常反映了所用机器中整数的最自然长度
	float 单精度浮点型
	double 双精度浮点型

	short int(short)	至少16位
	long int(long) 至少32位  

3: 字符常量是一个整数，即形如: '\0',整数值为0。

4: 常量表达式是仅仅只包含常量的表达式。这种表达式在编译时求值，而不在运行时求值。  

5: 字符串常量就是字符数组，字符串的内部表示使用一个空字符'\0'作为串的结尾，因此，存储字符串的物理存储单元数
比括在双引号中的字符数多一个。  

###2.4 声明

1: 所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地声明。还可以在声明的同时对变量进行初始化。
在声明中，如果变量名的后面紧跟一个等号以及一个表达式，该表达式就充当对变量进行初始化的初始化表达式。  

2: 如果变量不是自动变量，则只能进行一次初始化操作，应该是在程序开始执行之前，并且初始化表达式必须为**常量表达式**。

3: 默认情况下，外部变量于静态变量将初始化为0，未经显示初始化的自动变量的值为未定义(即无效值)。  

4: 使用const限定符限定的变量的值不能被修改。  

###2.7 类型转换  
1: C语言中，很多情况下会进行隐式的算术类型转换。一般来说，如果是二元运算符的两个操作数具有不同的类型，那么在
进行运算之前先要把"较低"的类型提升为"较高"的类型。运算的结果为"较高"的类型。在没有unsigned类型的操作数的情况下，则
只要使用下面的非正式的规则:  

	如果其中一个操作数为long double, 则将另一个转换为long double类型;
	如果其中一个操作数为double, 则将另一个转换为double;
	如果其中一个操作数为float，则将另一个转换为float;
	将char与short转换为int;
	如果其中一个操作数为long，则将另一个转还为long; 

###2.9 按位运算符

1: c语言提供了6个位操作运算符,这些运算符只能作用于整型操作数(即signed/unsigned char、short、int、long)。

	& 按位与(AND) 对应的位同时为1则结果为1;否则为0
	| 按位或(OR)  对应的位有一个为1则结果为1;否则为0
	^ 按位异或(XOR)	 对应的位不相同则结果为1;否则为0
	<< 左移
	>> 右移           将左操作数左移/右移 
	～ 按位求反(一元运算符) 1->0;0->1  

	进行左移操作时，结果等价于将 左操作数 * 2^右操作数  

###2.12 运算符优先级与求值次序

1: 运算符优先级

2: C语言没有指定同一个运算符中多个操作数的计算顺序。同时，也没有指定函数个参数的求值顺序。  

---------------------------------------------------

##Chapter3.控制流  

###3.8 goto语句与标号  

	int func(void) {
		while(true)
		{
			while(true)
			{
				goto error;
			}
		}
		//...

		error:
			//...
	}  

---------------------------------------------------

##Chapter4.函数与程序结构

###4.3 外部变量
1: C语程序可以看成由一系列的外部对象构成，这些外部对象可能是变量或者函数。由于C语言不允许在一个函数中定义其他函数，因此函数本身是"外部的"。  

2: 外部变量可以在全局范围内访问，与内部变量相比具有更大的作用域和更长的生存期。**自动变量**只能在函数内部访问，从其所在的函数被调用时变量开始存在，在函数退出时变量也将消失。而**外部变量**是永久存在的，它们的值在一次函数调用到下一次函数调用之间保持不变。  

###4.4 作用域规则  
1: 在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其他文件可以通过<code>extern</code>声明来访问它(定义外部变量的源文件中也可以包含对该外部变量的extern声明)。  

2: 外部变量的定义中必须指定数组的长度,但<code>extern</code>声明则不一定要指定数组的长度
	
	因为初始化需要分配存储空间，所以数组一定要指定长度  

3: 外部变量的初始化只能出现在其定义中。  

###4.6 静态变量  
1： 要将对象指定为静态存储，可以在正常的对象声明之前加上关键字static作为前缀。eg: <code>static int i</code>  

2： 外部的static声明通常多用于变量，当然，它也可用于声明函数。通常情况下，函数名字是全局可访问的，对整个程序的各个部分都是可见的。但是，如果把函数声明为static类型，则函数名除了对该函数声明所在的文件可见外，其他文件都无法访问。  

3： static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。  

###4.7 寄存器变量
1： register声明告诉编译器，它所声明的变量在程序中使用频率较高。其思想是，将register变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以忽略此选项。  


###4.9 初始化
1： 在不进行显示初始化的情况下，外部变量和静态变量都将被初始化为0，而自动变量和寄存器变量的初值未定义。  

2： 对于外部变量与静态变量来说，初始化表达式必须是**常量表达式**，且只初始化一次(从概念上讲是在程序开始执行之前进行初始化)。对于自动变量与寄存器变量，则在每次进入函数或程序块时都将被初始化。  

3： 对于自动变量与寄存器变量来说，初始化表达式可以不是常量表达式:表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用。  

4： 实际上，自动变量的初始化等效于简写的赋值语句。eg:

	int low, high, mid;
	low = 0;
	high = 1;
	mid = 2;
	========
	int low = 0, high=1, mid=2

5： 数组的初始化可以在声明的后面紧跟一个初始化表达式列表，eg:

	int days[] = {1, 2, 3, 4, 5};  

当省略数组的长度时，编译器将把花括号中的初始化表达式的个数作为数组的长度。  

6： 如果初始化表达式额个数比数组元素少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为0。如果初始化表达式的个数比数组元素数多，则是错误的。  

7： 字符数组的初始化比较特殊，下边两种形式的声明是相同的:
	
	char pattern[] = "ould";
	char pattern[] = {'o', 'u',  'l', 'd', '\0'};  

数组长度是5(4个字符加上一个字符串结束符'\0')。  

###4.11 C预处理器  

1： 宏的参数不能用带括号的字符串替换。但是，如果在替换文本中，参数名以#作为前缀则结果将被扩展为由实际参数替换该参数的带引号的字符串。eg:

	#define dprintf(expr) printf(#expr " = %g\n", expr)

使用语句 <code>dprintf(x/y)</code> 调用该宏时，宏将被扩展为:  

	printf("x/y" " = %g\n", x/y);  

2： 预处理器运算符##为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与##相邻，则该参数将被实际参数替换，##前后的空白符将被删除，并对替换后的结果重新扫描。eg:  

	#define paster(front, back)		front ## back

宏调用 <code>paster(name, 1)</code>的结果将建立记号： name1  

3： 条件包含。

	#if !define(HDR)
	#define HDR
	#endif 
	
	#if SYSTEM == SYSV
		#define HDR "sysv.h"
	#elif SYSTEM == BSD
		#define HDR "bsd.h"
	#else 
		#define HDR "default.h"
	#endif

	#ifdef
	#ifndef

-EOF-
