---
title: 标准I/O缓冲类型详解
layout: post
categories: [linux-c]
tags: [linux-c]
description: 标准I/O缓冲类型。
---  

这篇，主要来介绍下标准I/O的缓冲类型。  

通常，对一个进程预定以了三个流，并且着三个流可以自动的被进程使用，它们是:标准输入、标准输出和标准出错。 这些流引用的文件与文件I/O中的文件描述符:  

	STDIN_FILENO,STDOUT_FILENO,STDERR_FILENO  

所引用的文件相同。这三个标准I/O流通过预定义文件指针stdin,stdout和stderr加以引用。

标准I/O提供缓冲的目的是尽可能减少使用read和write调用的次数(因为文件I/O是没有缓冲的，每一次read/write调用，都需要对磁盘进行读写)。它也对每个I/O流自动的进行缓冲管理，从而避免了应用程序需要考虑这一点所带来的麻烦。  

下边我们看看标准I/O提供的三种类型的缓冲:  

1. 全缓冲。这种情况下，在填满标准I/O缓冲区后才进行实际I/O操作。对于驻留在磁盘上的文件通常是有标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。  

2. 行缓冲。 在这种情况下，当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符
(用标准I/O fputc函数)，但只有在写了一行之后才进行实际I/O操作。当涉及一个终端时(例如标准输入与标准输出)，通常使用行缓冲。  

3. 不带缓冲。  标准I/O库不对字符进行缓冲存储。例如，如果用标准I/O函数fputs写15个字符到不带缓冲的流中，则该函数很可能借助write(2)系统调用函数将这些字符立即写至相关联的打开文件上。  

我们能通常说的flush说明标准I/O缓冲区的写操作。缓冲区可由标转I/O程序自动flush(例如在填满一个缓冲区时)，或者可以调用fflush冲洗一个流。值得引起注意的是在UNIX环境中flush有两种意思。在标准I/O库方面，flush(冲洗)意味着将缓冲区中的内容写到磁盘(该缓冲区可能只是局部填写)。在终端驱动程序方面，flush(刷清)标识丢弃已存储在缓冲区中的数据。  

对于行缓冲有两个限制。第一，因为标准I/O库用来收集每一行的缓冲区的长度是固定的，所以只要填满了缓冲区，那么即使还没有写一个换行符，也进行I/O操作。第二，任何时候只要通过标准I/O库要求从(a)一个不带缓冲的流，或者(b)一个行缓冲的流(要求从内核得到数据)，得到输入数据，那么就会造成冲洗所有行缓冲输出流。在(b)中带了一个在括号中的说明，其理由是，所需的数据可能已在缓冲区中，它并不要求在需要数据时才从内核读数据。很明显，从不带缓冲的一个流中进行输入((a)项)要求当时从内核得到数据。  

标准出错流(stderr)通常是不带缓冲的，这就使得出错信息可以尽快显示出来，而不管它们是否还有一个换行符。  

IOS C要求下列缓冲特征:  

1. 当且仅当标准输入和标准输出不涉及交互设备时，它们才是全缓冲的。  
 
2. 标准出错绝不会是全缓冲的。    

当时这并没有告诉我们如果标准输入和输出涉及交互设备时，它们是不带缓冲的还是行缓冲的；以及标准出错是不带缓冲的还是行缓冲的。很多系统默认下列类型:  

1. 标准出错是不带缓冲的。 
 
2. 如果是涉及终端设备的其他流，则它们是行缓冲的；否则是全缓冲的。  

对任何给定的流，如果我们并不喜欢这些系统默认的情况，则可调用下列函数中的一个更改缓冲类型:  

	#include <stdio.h>
	
	void setbuf(FILE *fp, char *buf);

	int setvbuf(FILE *fp, char *buf, int mode, size_t size);
									//成功返回0;出错返回非0值  

这些函数一定要在流已被打开后调用(fp需要是一个有效的文件指针)，而且也应该在对流执行任何一个其他操作之前调用。  

使用setbuf打开或关闭缓冲机制。为了带缓冲进行I/O，参数buf必须指向一个长度BUFSIZ的缓冲区(该常量定义在<stdio.h>中)。通常在此之后该流就是全缓冲的，但是如果该流于一个终端设备相关，那么某些系统也可将其设置为行缓冲。为了关闭缓冲，将buf设置为NULL。  

使用setvbuf，我们可以精确地指定所需的缓冲类型。由mode参数指定:  

	_IOFBF 全缓冲
	_IOLBF 行缓冲
	_IONBF 无缓冲  

我们看下apue中的总结:

![img1][standard_io_buf]

> 通常，应由系统选择缓冲区的长度，并自动分配缓冲区。在这种情况下关闭此流时，标准I/O库将自动释放缓冲区。  

任何时候，我们都可以强制刷新一个流:  

	#include <stdio.h>
	int fflush(FILE *fp);

[standard_io_buf]: https://raw.github.com/yuxingfirst/blog/gh-pages/_images/linux-c/standard_io_buf.png  

-EOF-
